extern crate rand;
use rand::Rng;

extern crate crypto;
use crypto::md5::Md5;
use crypto::digest::Digest;

struct Trinket{
    pub_key: u64,
    sec_key: u64,
    g: u32,
    p: u64,
}

struct Car{
    pub_key: u64,
    sec_key: u64,
    g: u32,
    p: u64,
    cmd_hash: String,
}

fn build_trinket(pub_key: u64, sec_key: u64, prime: u64, pow:u32) -> Trinket {
    Trinket {
        pub_key: pub_key,
        sec_key: sec_key,
        g: pow,
        p: prime,
    }
}

fn build_car(pub_key: u64, sec_key: u64, prime: u64, pow:u32) -> Car {
    Car {
        pub_key: pub_key,
        sec_key: sec_key,
        g: pow,
        p: prime,
        cmd_hash: " ".to_string(),
    }
}

fn register_keys() -> (u64, u64){
    let tr_key = 13134123;
    let car_key = 17123414;
    return(tr_key, car_key);
}
//this function quick pows, and mods result with given u64 module 
fn modded_pow(exponent:u64, key:u64, module:u64)-> u64{
    let mut t :u128 = 1;
    let mut _key = key as u128;
    let mut _exponent = exponent as u128;
    let _module = module as u128;
    while _key != 0{
        if _key & 1 == 1{
            t *= _exponent;
            t %= _module;
        }
        _exponent *= _exponent;
        _exponent %= _module;
        _key >>= 1;
    }

    t as u64 
}

fn main() {
    //generating all needed parameters
    
    let (trinket_pub_key ,car_pub_key)  = register_keys();
    //this prime number is biggest possible in u64
    let (prime, power) = (18446744073709551557 as u64, 23 as u32);  

    let mut tr = build_trinket(trinket_pub_key, 0, prime, power);
    let mut car = build_car(car_pub_key, 0, prime, power);
    
    println!("(registration) (trinket initialized with pkey {}), (car initialized with pkey {})", trinket_pub_key, car_pub_key);
    
    //here is implementation of Diffieâ€“Hellman algorithm
    let num_a = modded_pow(tr.g as u64, tr.pub_key, tr.p);

    println!("(handshake) trinket->car send data: {}", num_a);
    let num_b = trinket_generate_handshake(num_a, &mut car);
    println!("(handshake) car->trinket send data: {}", num_b);
    tr.sec_key = modded_pow(num_b, tr.pub_key, tr.p);
    
    if tr.sec_key == car.sec_key{
    println!("Seckey generated, Handshake succed!");
    } else{
        panic!("Handshake failed, keys doesnt match.");
    }

    println!("(challenge) trinket->car request challenge");
    let challenge_key = car_request_challenge(&mut car);
    println!("(challenge) car->trinket challenge {} sent", challenge_key);
    let challenge_hash = generate_sig(tr.sec_key, challenge_key);

    println!("verifying hashes...");

    if car_get_challenge(&challenge_hash, &mut car){
        println!("Car opened!");
    } else {
        panic!("hashes wrong, on tr: {}, on car: {}", challenge_hash, car.cmd_hash);
    }
}

/*this func generates md5-hash string from key generated by car,
 and secret key acquired from handshake*/
fn generate_sig(sec_key:u64, rand_key: u32)->String{
    let mut digest = Md5::new();
    let input :String = rand_key.to_string() + &sec_key.to_string();
    digest.input_str(&input);
    return digest.result_str();
}

fn verify_sig(a1:&String, a2:&String)->bool{
    let x = if *a1 == *a2 {
        true} else {
            false
        };
    return x;
}

//from here starts code running on car, working with trinket requests


fn trinket_generate_handshake(num_a: u64, car: &mut Car) -> u64{
    car.sec_key = modded_pow(num_a, car.pub_key, car.p);

    let num_b = modded_pow(car.g as u64, car.pub_key,car.p);
    num_b
}
/* this func generates and sends back random challenge for trinket, 
also it saves hash expected from trinket */
fn car_request_challenge(car: &mut Car) -> u32{
    let rand_key = rand::thread_rng().gen_range(1, u32::MAX);
    let challenge_hash = generate_sig(car.sec_key, rand_key);
    car.cmd_hash = challenge_hash;
    return rand_key;
}

//verifying trinket hash with right one
fn car_get_challenge(inp: &String, car: &mut Car)->bool{
    let cond = verify_sig(&inp, &car.cmd_hash);
    if cond {
        return true;
    } else {
    return false;
    }
}



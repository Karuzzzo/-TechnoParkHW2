extern crate rand;
use rand::Rng;

extern crate crypto;
use crypto::md5::Md5;
use crypto::digest::Digest;

struct Trinket{
    pub_key: u32,
    sec_key: u128,
    g: u128,
    p: u128,
}

struct Car{
    pub_key: u32,
    sec_key: u128,
    g: u128,
    p: u128,
    cmd_hash: String,
}

fn build_trinket(pub_key: u32, sec_key: u128) -> Trinket {
    Trinket {
        pub_key: pub_key,
        sec_key: sec_key,
        g: 3,
        p: 257,
    }
}

fn build_car(pub_key: u32, sec_key: u128) -> Car {
    Car {
        pub_key: pub_key,
        sec_key: sec_key,
        g: 3,
        p: 257,
        cmd_hash: " ".to_string(),
    }
}

fn register_keys() -> (u32, u32){
    let tr_key :u32 = 13;
    let car_key: u32 = 17;
    return(tr_key, car_key);
}
fn main() {
    let (trinket_pub_key ,car_pub_key)  = register_keys();

    let mut tr = build_trinket(trinket_pub_key, 0);
    let mut car = build_car(car_pub_key, 0);

    println!("(registration) (trinket initialized with pkey {}), (car initialized with pkey {})", trinket_pub_key, car_pub_key);
    
    //here is implementation of Diffieâ€“Hellman algorithm
    let num_a :u128 = ((tr.g.wrapping_pow(tr.pub_key))%tr.p).into();
    println!("(handshake) trinket->car send data: {}", num_a);
    let num_b: u128 = trinket_generate_handshake(num_a, &mut car);
    println!("(handshake) car->trinket send data: {}", num_b);
    tr.sec_key = (num_b.wrapping_pow(tr.pub_key))%tr.p;
    
    if tr.sec_key == car.sec_key{
    println!("Seckey generated, Handshake succed!");
    } else{
        panic!("Handshake failed, keys doesnt match.");
    }

    println!("(challenge) trinket->car request challenge");
    let challenge_key = car_request_challenge(&mut car);
    println!("(challenge) car->trinket challenge {} sent", challenge_key);
    let challenge_hash = generate_sig(tr.sec_key, challenge_key);

    println!("verifying hashes...");

    if car_get_challenge(&challenge_hash, &mut car){
        println!("Car opened!");
    } else {
        panic!("hashes wrong, on tr: {}, on car: {}", challenge_hash, car.cmd_hash);
    }
}

/*this func generates md5-hash string from key generated by car,
 and secret key acquired from handshake*/
fn generate_sig(sec_key:u128, rand_key: u32)->String{
    let mut digest = Md5::new();
    let input :String = rand_key.to_string() + &sec_key.to_string();
    digest.input_str(&input);
    return digest.result_str();
}

fn verify_sig(a1:&String, a2:&String)->bool{
    let x = if *a1 == *a2 {
        true} else {
            false
        };
    return x;
}

//from here starts code running on car, working with trinket requests


fn trinket_generate_handshake(num_a: u128, car: &mut Car) -> u128{
    car.sec_key = (num_a.wrapping_pow( car.pub_key) % car.p).into();

    let num_b: u128 = car.g.wrapping_pow(car.pub_key) % car.p;
    return num_b;
}
/* this func generates and sends back random challenge for trinket, 
also it saves hash expected from trinket */
fn car_request_challenge(car: &mut Car) -> u32{
    let rand_key = rand::thread_rng().gen_range(1, u32::MAX);
    let challenge_hash = generate_sig(car.sec_key, rand_key);
    car.cmd_hash = challenge_hash;
    return rand_key;
}

//verifying trinket hash with right one
fn car_get_challenge(inp: &String, car: &mut Car)->bool{
    let cond = verify_sig(&inp, &car.cmd_hash);
    if cond {
        return true;
    } else {
    return false;
    }
}


